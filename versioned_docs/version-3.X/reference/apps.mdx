# Infrastructure Apps

Infrastructure apps are low-code apps that can be installed on Resoto to extend its functionality. They can be used to perform simple tasks such as cleaning up untagged resources, finding abandoned load balancers or sending notifications to Slack, Discord or PagerDuty.

## What is an Infrastructure App and how does it work?

An infrastructure app is a [Jinja template](https://jinja.palletsprojects.com/) that generates one or more Resoto commands which are then executed by Resoto one after the other.

## How do I find and install an Infrastructure App?

Using the [`apps`](cli/miscellaneous-commands/apps/index.mdx) command you can search for apps and install them:

```bash title="Searching for apps"
> apps search cleanup
```

```bash title="Installing an app"
> apps install cleanup-untagged
```

```bash title="Running an app"
> apps run cleanup-untagged --dry-run
# or
> cleanup-untagged --dry-run
```

The `--dry-run` flag is optional and can be used to see what commands would be executed without actually executing them.

See the [`apps CLI reference`](cli/miscellaneous-commands/apps/index.mdx) for more detailed usage information.

## How safe are Resoto infrastructure apps?

An infrastructure app can not execute any Resoto commands directly. Instead, it generates Resoto commands which are then executed by Resoto. This means when you `--dry-run` an infrastructure app, you can see exactly what commands would be executed.

An app has reading access to the Resoto Infrastructure Graph using the `search()` function. This means it can only read information about resources that are already known to Resoto but not change them. To change resources, an app has to generate a Resoto command that does so.

## How can I develop my own infrastructure apps?

Check out the [Resoto Apps git repository](https://github.com/someengineering/resoto-apps) for a list of existing apps.

Using [`resotoappbundler`](https://github.com/someengineering/resotoappbundler) (`pip install resotoappbundler`) you can bundle and dry-run (`resotoapprunner`) your app locally.

`resotoappbundler` takes one or more Resoto app directories and bundles them into a single JSON file. This file can be hosted on any http server and used as an app index URL.

### Example Development Workflow

An example that would set up a new Python virtual env, install Resoto App Bundler, clone the Resoto Apps repository and bundle all apps into an `index.json` file:

```bash
# create a new directory for the resoto apps and change into it
$ mkdir resoto-app-development
$ cd resoto-app-development
# create a new python virtual env and activate it
$ python3 -m venv resoto-apps-venv
$ source resoto-apps-venv/bin/activate
# install resotoappbundler
$ pip install resotoappbundler
# checkout the resoto-apps repository
$ git clone https://github.com/someengineering/resoto-apps.git
# bundle all apps into a single index.json file that can be hosted on any http server
$ resotoappbundler --path resoto-apps/ --discover > index.json
# dry-run the cleanup-untagged app for an example of how the output of an infrastructure app looks like
$ resotoapprunner --path resoto-apps/cleanup-untagged/
```

Within Resoto Shell you can then install the app using the `app install` command:

```bash title="Installing an app from a custom index URL"
> app install <app_name> [--index-url https://cdn.some.engineering/resoto/apps/index.json]
```

During local development the index-url can also be `file://...` to point to a local json file.

### Extra functions and variables not part of standard Jinja

A Resoto Infrastructure App has access to a couple of extras that are not part of the standard Jinja library:

- `search()` - Search the Resoto Graph for resources. Returns a generator that yields resources (and edges if requested).
- `parse_duration()` - Parse a duration string (e.g. `2d4h` or `7 weeks`) into a timedelta object that can be compared.
- `config` - The app configuration.
- `args` - The command line arguments passed to the app if any.
- `stdin` - A generator representing the standard input passed to the app if any.

### Directory Layout

An infrastructure app is a directory that contains the following files:

- `README.md` - A markdown file that describes the app.
- `app.yaml` - A YAML file that contains the app manifest.
- `app.jinja2` - A Jinja template that generates Resoto commands.
- `app.svg` - A vector graphics icon for the app.

### App Manifest

The app manifest is a YAML file that contains the following fields:

- `name` - The name of the app.
- `description` - A short description of the app.
- `version` - The version of the app.
- `language` - The language of the app. Currently only `jinja2` is supported.
- `license` - The license of the app.
- `authors` - A list of authors.
- `url` - The URL of the app.
- `categories` - A list of categories the app belongs to.
- `default_config` - The default configuration of the app.
- `config_schema` - The configuration schema of the app.
- `args_schema` - The command line arguments schema of the app.

### A couple of example apps

#### A simple app that executes a static search with no dynamic code

```jinja title="app.jinja2"
search /metadata.expires < "@NOW@" | clean "Resource is expired"
```

```yaml title="app.yaml"
name: cleanup-expired
description: "This app cleans up resources that have expired."
version: "1.0.0"
language: jinja2
license: "Apache 2.0"
authors: ["someengineering"]
url: "https://resoto.com/"
categories: ["cleanup"]
default_config:
config_schema:
args_schema:
```

#### An app that cleans up abandoned AWS CloudWatch Instance Alarms

```jinja title="app.jinja2"
{%- set config = config["cleanup_aws_alarms"] %}
{%- for cloud, accounts in config["clouds_and_accounts"].items() %}
    {%- for account in accounts %}
search is(aws_cloudwatch_alarm) and /ancestors.account.reported.id == "{{account}}" and /ancestors.cloud.reported.id == "{{cloud}}" and cloudwatch_dimensions[*].name = InstanceId with (empty, <-- is(aws_ec2_instance)) | clean "Abandoned CloudWatch Instance Alarm"
    {%- endfor %}
{%- endfor %}
```

```yaml title="app.yaml"
name: cleanup-aws-alarms
description: "This plugin marks all abandoned AWS CloudWatch Instance Alarms for cleanup."
version: "1.0.0"
language: jinja2
license: "Apache 2.0"
authors: ["someengineering"]
url: "https://resoto.com/"
categories: ["cleanup"]
default_config:
  cleanup_aws_alarms:
    clouds_and_accounts:
      aws:
        - '1234567'
        - '567890'
config_schema:
  - fqn: cleanup_aws_alarms
    bases: []
    properties:
    - name: clouds_and_accounts
      kind: dictionary[string, string[]]
      required: false
      description: Clouds and accounts to cleanup AWS alarms in.
args_schema:
```

#### A Discord app that sends a message to a Discord channel

```jinja title="app.jinja2"
{%- set config = config["discord"] %}
{%- set message = [] %}
{%- for resource in stdin %}
    {%- set reported = resource.get("reported", {}) %}
    {%- set ancestors = resource.get("ancestors", {}) %}
    {%- set account = ancestors.get("account", {}).get("reported", {}).get("name") %}
    {%- set kind = reported.get("kind") %}
    {%- set id = reported.get("id") %}
    {%- set name = reported.get("id") %}
    {%- if id == name %}
        {%- set dname = id %}
    {%- else %}
        {%- set dname = name ~ ' (' ~ id ~ ')' %}
    {%- endif %}
    {%- set kdname = account ~ ' - ' ~ kind ~ ' ' ~ dname %}
    {%- do message.append(kdname) %}
{%- endfor %}
{%- set message = message | join(" | ") %}
{%- set discord_data = {"embeds": [{"type": "rich", "title": args.title, "description": message, "footer": {"text": "Message created by Resoto"}}]} %}
json {{ discord_data | tojson }} | http POST {{ config["webhook"] }}
```

```yaml title="app.yaml"
name: discord
description: "Discord client for Resoto"
version: "1.0.0"
language: jinja2
license: "Apache 2.0"
authors: ["someengineering"]
url: "https://resoto.com/"
categories: ["tools"]
default_config:
  discord:
    webhook: 'https://discordapp.com/api/webhooks/1234567890/abcdefghijklmnopqrstuvwxyz'
config_schema:
  - fqn: discord
    bases: []
    properties:
    - name: webhook
      kind: string
      required: true
      description: Discord Webhook URL.
args_schema:
  title:
    help: "Title of the message to send to Discord."
    type: str
    required: true
  message:
    help: "Message to send to Discord."
    type: str
    required: true
  num:
    help: "Message to send to Discord."
    type: int
    default: 10
```
